name: Windows Build & Sign

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v4

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2

    - name: Setup MSVC (cl.exe)
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64

    # Install Windows Driver Kit (WDK)
    # This is required to build the driver.
    - name: Install WDK
      run: |
        Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2196230" -OutFile "wdksetup.exe"
        Start-Process -FilePath "wdksetup.exe" -ArgumentList "/quiet /norestart /features +" -Wait
      shell: powershell

    - name: Find WDK Library Path
      run: |
        Write-Host "--- Debugging WDK Installation ---"
        
        # Check Lib root to see installed SDK versions
        $libRoot = "C:\Program Files (x86)\Windows Kits\10\Lib"
        if (Test-Path $libRoot) {
            Write-Host "SDK Versions in $libRoot :"
            Get-ChildItem -Path $libRoot -Directory | Select-Object Name
            
            # Check wdf folder
            $wdfRoot = "$libRoot\wdf"
            if (Test-Path $wdfRoot) {
                Write-Host "WDF Root contents:"
                Get-ChildItem -Path $wdfRoot -Directory | Select-Object Name
                
                # Check umdf folder
                $umdfRoot = "$wdfRoot\umdf"
                if (Test-Path $umdfRoot) {
                    Write-Host "UMDF Architectures:"
                    Get-ChildItem -Path $umdfRoot -Directory | Select-Object Name
                    
                    # Check x64 content specifically if it exists
                    $x64 = "$umdfRoot\x64"
                    if (Test-Path $x64) {
                         Write-Host "UMDF x64 Versions:"
                         Get-ChildItem -Path $x64 -Directory | Select-Object Name
                         
                         # Check for any .lib files in the latest version
                         $latest = Get-ChildItem -Path $x64 -Directory | Sort-Object Name -Descending | Select-Object -First 1
                         if ($latest) {
                            Write-Host "Listing .lib files in $($latest.FullName):"
                            Get-ChildItem -Path $latest.FullName -Filter "*.lib" | Select-Object Name
                         }
                    } else {
                        Write-Warning "UMDF x64 folder MISSING at $x64"
                    }
                } else {
                    Write-Warning "UMDF folder MISSING at $umdfRoot"
                }
            } else {
                Write-Warning "wdf folder MISSING at $wdfRoot"
            }
        } else {
            Write-Warning "Lib root MISSING at $libRoot"
        }
        
        Write-Host "--- End Debug ---"

        # Resume search logic
        $kitsRoots = @("C:\Program Files (x86)\Windows Kits", "C:\Program Files\Windows Kits")
        $foundFiles = @()

        foreach ($root in $kitsRoots) {
            if (Test-Path $root) {
                $files = Get-ChildItem -Path $root -Filter "WdfDriverEntry.lib" -Recurse -ErrorAction SilentlyContinue
                if ($files) {
                    $foundFiles += $files
                }
            }
        }
        
        if ($foundFiles.Count -gt 0) {
            $foundFiles | ForEach-Object { Write-Host "Found: $($_.FullName)" }
            
            # Filter for UMDF and x64
            $best = $foundFiles | Where-Object { $_.FullName -like "*umdf*x64*" } | Sort-Object FullName -Descending | Select-Object -First 1
            
            if ($best) {
                $libPath = $best.DirectoryName
                Write-Host "Selected: $libPath"
                echo "WDF_LIB_PATH=$libPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8
            } else {
                 Write-Warning "Found copies but none matched *umdf*x64*."
                 exit 1
            }
        } else {
            Write-Error "WdfDriverEntry.lib not found anywhere."
            exit 1
        }
      shell: powershell

    - name: Build Windows Applications
      run: |
        call build_windows.bat
      shell: cmd

    # Driver Build Step - Requires Project Files
    # For now, we will attempt to build if the solution exists, or warn if it doesn't.
    # We will generate a minimal solution/project if missing in a later step or assume user adds it.
    # To make this pipeline work immediately, I will add a step to generate the project files if they don't exist,
    # or I will commit them to the repo in this session.

    - name: Build Driver (UMDF)
      run: |
        if exist "src\windows\driver\VirtualCom.sln" (
          msbuild src\windows\driver\VirtualCom.sln /p:Configuration=Release /p:Platform=x64 /p:WdfLibPath="%WDF_LIB_PATH%"
        ) else (
          echo "WARNING: VirtualCom.sln not found. Skipping driver build."
        )
      shell: cmd

    - name: Sign Artifacts
      shell: powershell
      env:
        CERT_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}
        CERT_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
      run: |
        $certPath = "cert.pfx"
        $certPassword = $env:CERT_PASSWORD
        
        if ($env:CERT_BASE64) {
          Write-Host "Decoding certificate from secrets..."
          [IO.File]::WriteAllBytes("cert.pfx", [Convert]::FromBase64String($env:CERT_BASE64))
        } else {
          Write-Host "No secret provided. Generating Self-Signed Certificate for Testing..."
          $cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject "CN=VirtualComTest" -CertStoreLocation Cert:\LocalMachine\My
          $password = ConvertTo-SecureString -String "password" -Force -AsPlainText
          Export-PfxCertificate -Cert $cert -FilePath $certPath -Password $password
          $certPassword = "password"
          
          # Trust it for testing
          Export-Certificate -Cert $cert -FilePath "driver.cer"
          Import-Certificate -FilePath "driver.cer" -CertStoreLocation Cert:\LocalMachine\Root
          Import-Certificate -FilePath "driver.cer" -CertStoreLocation Cert:\LocalMachine\TrustedPublisher
        }
        
        # Locate signtool
        $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Filter "signtool.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName
        if (-not $signtool) {
            Write-Error "Signtool not found."
            exit 1
        }
        Write-Host "Using Signtool: $signtool"
        
        # Sign Executables
        $exePath = "build\windows\EasyCOM.exe"
        if (Test-Path $exePath) {
             & $signtool sign /f $certPath /p $certPassword /fd sha256 /tr http://timestamp.digicert.com /td sha256 $exePath
        }

        # Sign Driver
        $driverPath = "src\windows\driver\x64\Release\VirtualCom"
        if (Test-Path "$driverPath\VirtualCom.dll") {
             Write-Host "Signing Driver..."
             & $signtool sign /f $certPath /p $certPassword /fd sha256 /tr http://timestamp.digicert.com /td sha256 "$driverPath\VirtualCom.dll"
             & $signtool sign /f $certPath /p $certPassword /fd sha256 /tr http://timestamp.digicert.com /td sha256 "$driverPath\VirtualCom.cat"
        }

    - name: Test Driver Installation
      shell: powershell
      run: |
        $driverPath = "src\windows\driver\x64\Release\VirtualCom"
        $infPath = "$driverPath\virtual_com.inf"
        
        # Install Driver using pnputil
        Write-Host "Installing Driver from $infPath..."
        pnputil /add-driver $infPath /install
        
        # Wait for device enumeration
        Start-Sleep -Seconds 5
        
        # Verify Installation
        $dev = Get-PnpDevice -FriendlyName "Virtual Serial Port (UMDF)" -ErrorAction SilentlyContinue
        if ($dev) {
            Write-Host "Device Installed Successfully: $($dev.FriendlyName) ($($dev.Status))"
        } else {
            Write-Warning "Device not found immediately. Proceeding to functional test..."
        }
        
        # Run Functional Test Script
        ./tests/test_driver_pipeline.ps1

    - name: Setup Inno Setup
      run: |
        choco install -y innosetup

    - name: Build Installer
      run: |
        "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "installer\VirtualComInstaller.iss"
      shell: cmd

    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Windows-Installer-and-Binaries
        path: |
          build/windows/*.exe
          installer/Output/*.exe
          src/windows/driver/x64/Release/VirtualCom/*
